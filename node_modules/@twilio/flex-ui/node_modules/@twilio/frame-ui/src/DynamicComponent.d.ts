import * as React from "react";
import { OptionalThemeProps } from "emotion-theming";
import { DynamicContentStore } from "./DynamicContentStore";
export * from "./DynamicContentStore";
export declare type ContentFragmentAlignment = "start" | "end";
/**
 * Dynamically populated children which will receive props of type T.
 * @typedef {(React.ReactElement<T>)} DynamicComponentChildren
 */
export interface ContentFragmentProps {
    align?: ContentFragmentAlignment;
    replace?: boolean;
    sortOrder?: number;
    if?: (props: any) => boolean;
}
export interface RemoveComponentCallOptions {
    if?: (props: any) => boolean;
}
export interface RemoveComponentCall {
    key: React.Key;
    options: RemoveComponentCallOptions;
}
export declare class ContentFragment extends React.Component<ContentFragmentProps> {
    render(): React.ReactNode;
}
export declare class DefaultContentFragment extends React.Component<any> {
    render(): React.ReactNode;
}
export interface DynamicComponentProps {
    childProps?: any;
    contentStore: DynamicContentStore;
    className?: string;
    customChildren?: React.ReactNode;
    vertical?: boolean;
    name: string;
    noContainers?: boolean;
    subContainer?: React.ReactElement<any>;
    renderChildren?: (children: Array<React.ReactNode>, align: string) => Array<React.ReactNode>;
}
export declare class DynamicComponent<Theme> extends React.PureComponent<OptionalThemeProps<DynamicComponentProps, Theme>, undefined> {
    static readonly displayName = "DynamicComponent";
    private theme;
    context: {
        [key: string]: any;
    };
    private themeUnsubscribeId;
    constructor(props: DynamicComponentProps);
    componentWillMount(): void;
    componentWillUnmount(): void;
    private parseFragment;
    render(): React.ReactElement<any>;
    static cloneElementWithProps(child: React.ReactChild, addedProps: any): React.ReactChild;
    static contextTypes: any;
}
