/// <reference types="node" />
import { EventEmitter } from "events";
export declare type ActionFunction = (payload: any, cancelCb?: any) => Promise<any>;
export declare type ReplacedActionFunction = (payload: any, original: ActionFunction) => Promise<any>;
export declare type ActionIsEnabledFunction = (payload: any) => boolean;
export declare type PayloadUpdateFunction = (payload: any) => any;
export declare class ActionsImpl extends EventEmitter {
    private actions;
    private replacedActions;
    private payloadUpdateFunctions;
    /**
     * Registers an action
     * @param  {string} name Name of the action to register.
     * @param  {ActionFunction} action A function to execute when the action is invoked.
     * @param  {PayloadUpdateFunction} [payloadUpdateFunction] A function to update the payload.
     */
    registerAction(name: string, action: ActionFunction, payloadUpdateFunction?: PayloadUpdateFunction): void;
    /**
     * Invokes an action
     * @param  {string} name Name of the action to invoke.
     * @param  {any} [payload] Data to be passed to an action while invoking.
     * @returns Promise
     */
    invokeAction(name: string, payload?: any): Promise<any>;
    /**
     * To prevent promise.all to stop waiting for promises after the first rejection,,
     * we add a custom "catch" logic to each of the values returned from an eventListener,
     * if this is a promise.
     * @private
     */
    private catchErrorIfIsPromise;
    private customEmit;
    /**
     * Replace an existing action
     * @param  {string} name An action name to be replaced.
     * @param  {ReplacedActionFunction} action A new function for an action to be replaced.
     */
    replaceAction(name: string, action: ReplacedActionFunction): void;
    /**
     * @deprecated Use Action.invokeAction instead.
     */
    emit(...args: Array<any>): boolean;
}
export declare const Actions: ActionsImpl;
