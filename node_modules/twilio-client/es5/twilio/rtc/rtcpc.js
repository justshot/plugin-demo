/* global webkitRTCPeerConnection, mozRTCPeerConnection, mozRTCSessionDescription, mozRTCIceCandidate */
var RTCPeerConnectionShim = require('rtcpeerconnection-shim');
var util = require('../util');
function RTCPC() {
    if (typeof window === 'undefined') {
        this.log('No RTCPeerConnection implementation available. The window object was not found.');
        return;
    }
    if (util.isEdge()) {
        this.RTCPeerConnection = new RTCPeerConnectionShim(typeof window !== 'undefined' ? window : global);
    }
    else if (typeof window.RTCPeerConnection === 'function') {
        this.RTCPeerConnection = window.RTCPeerConnection;
    }
    else if (typeof window.webkitRTCPeerConnection === 'function') {
        this.RTCPeerConnection = webkitRTCPeerConnection;
    }
    else if (typeof window.mozRTCPeerConnection === 'function') {
        this.RTCPeerConnection = mozRTCPeerConnection;
        window.RTCSessionDescription = mozRTCSessionDescription;
        window.RTCIceCandidate = mozRTCIceCandidate;
    }
    else {
        this.log('No RTCPeerConnection implementation available');
    }
}
RTCPC.prototype.create = function (log, rtcConstraints, rtcConfiguration) {
    this.log = log;
    this.pc = new this.RTCPeerConnection(rtcConfiguration, rtcConstraints);
};
RTCPC.prototype.createModernConstraints = function (c) {
    // createOffer differs between Chrome 23 and Chrome 24+.
    // See https://groups.google.com/forum/?fromgroups=#!topic/discuss-webrtc/JBDZtrMumyU
    // Unfortunately I haven't figured out a way to detect which format
    // is required ahead of time, so we'll first try the old way, and
    // if we get an exception, then we'll try the new way.
    if (typeof c === 'undefined') {
        return null;
    }
    // NOTE(mroberts): As of Chrome 38, Chrome still appears to expect
    // constraints under the 'mandatory' key, and with the first letter of each
    // constraint capitalized. Firefox, on the other hand, has deprecated the
    // 'mandatory' key and does not expect the first letter of each constraint
    // capitalized.
    var nc = {};
    if (typeof webkitRTCPeerConnection !== 'undefined' && !util.isEdge()) {
        nc.mandatory = {};
        if (typeof c.audio !== 'undefined') {
            nc.mandatory.OfferToReceiveAudio = c.audio;
        }
        if (typeof c.video !== 'undefined') {
            nc.mandatory.OfferToReceiveVideo = c.video;
        }
    }
    else {
        if (typeof c.audio !== 'undefined') {
            nc.offerToReceiveAudio = c.audio;
        }
        if (typeof c.video !== 'undefined') {
            nc.offerToReceiveVideo = c.video;
        }
    }
    return nc;
};
RTCPC.prototype.createOffer = function (constraints, onSuccess, onError) {
    var self = this;
    constraints = this.createModernConstraints(constraints);
    promisifyCreate(this.pc.createOffer, this.pc)(constraints).then(function (sd) { return self.pc && promisifySet(self.pc.setLocalDescription, self.pc)(new RTCSessionDescription(sd)); }).then(onSuccess, onError);
};
RTCPC.prototype.createAnswer = function (constraints, onSuccess, onError) {
    var self = this;
    constraints = this.createModernConstraints(constraints);
    promisifyCreate(this.pc.createAnswer, this.pc)(constraints).then(function (sd) { return self.pc && promisifySet(self.pc.setLocalDescription, self.pc)(new RTCSessionDescription(sd)); }).then(onSuccess, onError);
};
RTCPC.prototype.processSDP = function (sdp, constraints, onSuccess, onError) {
    var self = this;
    var desc = new RTCSessionDescription({ sdp: sdp, type: 'offer' });
    promisifySet(this.pc.setRemoteDescription, this.pc)(desc).then(function () {
        self.createAnswer(constraints, onSuccess, onError);
    });
};
RTCPC.prototype.getSDP = function () {
    return this.pc.localDescription.sdp;
};
RTCPC.prototype.processAnswer = function (sdp, onSuccess, onError) {
    if (!this.pc) {
        return;
    }
    promisifySet(this.pc.setRemoteDescription, this.pc)(new RTCSessionDescription({ sdp: sdp, type: 'answer' })).then(onSuccess, onError);
};
/* NOTE(mroberts): Firefox 18 through 21 include a `mozRTCPeerConnection`
   object, but attempting to instantiate it will throw the error

       Error: PeerConnection not enabled (did you set the pref?)

   unless the `media.peerconnection.enabled` pref is enabled. So we need to test
   if we can actually instantiate `mozRTCPeerConnection`; however, if the user
   *has* enabled `media.peerconnection.enabled`, we need to perform the same
   test that we use to detect Firefox 24 and above, namely:

       typeof (new mozRTCPeerConnection()).getLocalStreams === 'function'

*/
RTCPC.test = function () {
    if (typeof navigator === 'object') {
        var getUserMedia = (navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
            || navigator.webkitGetUserMedia
            || navigator.mozGetUserMedia
            || navigator.getUserMedia;
        if (getUserMedia && typeof window.RTCPeerConnection === 'function') {
            return true;
        }
        else if (getUserMedia && typeof window.webkitRTCPeerConnection === 'function') {
            return true;
        }
        else if (getUserMedia && typeof window.mozRTCPeerConnection === 'function') {
            try {
                // eslint-disable-next-line babel/new-cap
                var test_1 = new window.mozRTCPeerConnection();
                if (typeof test_1.getLocalStreams !== 'function')
                    return false;
            }
            catch (e) {
                return false;
            }
            return true;
        }
        else if (typeof RTCIceGatherer !== 'undefined') {
            return true;
        }
    }
    return false;
};
function promisify(fn, ctx, areCallbacksFirst) {
    return function () {
        var args = Array.prototype.slice.call(arguments);
        return new Promise(function (resolve) {
            resolve(fn.apply(ctx, args));
        }).catch(function () { return new Promise(function (resolve, reject) {
            fn.apply(ctx, areCallbacksFirst
                ? [resolve, reject].concat(args)
                : args.concat([resolve, reject]));
        }); });
    };
}
function promisifyCreate(fn, ctx) {
    return promisify(fn, ctx, true);
}
function promisifySet(fn, ctx) {
    return promisify(fn, ctx, false);
}
module.exports = RTCPC;
//# sourceMappingURL=rtcpc.js.map